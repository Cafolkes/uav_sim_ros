//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: matDFcl.cpp
//
// MATLAB Coder version            : 4.2
// C/C++ source code generated on  : 27-Feb-2020 15:18:17
//

// Include Files
#include <cmath>
#include <math.h>
#include "rt_nonfinite.h"
#include <string.h>
#include "UAVDynamicsWithGrad.h"
#include "matDFcl.h"

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions

//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_powd_snf(double u0, double u1)
{
  double y;
  double d0;
  double d1;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d0 = std::abs(u0);
    d1 = std::abs(u1);
    if (rtIsInf(u1)) {
      if (d0 == 1.0) {
        y = 1.0;
      } else if (d0 > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

//
// MATDFCL
//     DFCL = MATDFCL(IN1,IN2)
// Arguments    : const double in1[17]
//                double DFcl[289]
// Return Type  : void
//
void matDFcl(const double in1[17], double DFcl[289])
{
  double t6;
  double t7;
  double t8;
  double t9;
  double t11;
  double t12;
  double t13;
  double t14;
  double t15;
  double t16;
  double t17;
  double t25;
  double t53;
  double t26;
  double t27;
  double t28;
  double t29;
  double t30;
  double t52;
  double t40;
  double t41;
  double t42;
  double t43;
  double t46;
  double t47;
  double DFcl_tmp;
  double b_DFcl_tmp;
  double c_DFcl_tmp;
  double d_DFcl_tmp;

  //     This function was generated by the Symbolic Math Toolbox version 8.3.
  //     27-Feb-2020 15:18:11
  t6 = in1[3] * in1[3];
  t7 = in1[4] * in1[4];
  t8 = in1[5] * in1[5];
  t9 = in1[6] * in1[6];
  t11 = in1[3] / 2.0;
  t12 = in1[4] / 2.0;
  t13 = in1[5] / 2.0;
  t14 = in1[6] / 2.0;
  t15 = in1[10] / 2.0;
  t16 = in1[11] / 2.0;
  t17 = in1[12] / 2.0;
  t25 = 1.0 / (((t6 + t7) + t8) + t9);
  t53 = ((in1[13] * in1[13] * 9.9009900990099013E-6 + in1[14] * in1[14] *
          9.9009900990099013E-6) + in1[15] * in1[15] * 9.9009900990099013E-6) +
    in1[16] * in1[16] * 9.9009900990099013E-6;
  t26 = t25 * t25;
  t27 = in1[3] * t25 * 2.0;
  t28 = in1[4] * t25 * 2.0;
  t29 = in1[5] * t25 * 2.0;
  t30 = in1[6] * t25 * 2.0;
  t52 = in1[3] * in1[4];
  t40 = t52 * in1[5] * t26 * 4.0;
  t41 = t52 * in1[6] * t26 * 4.0;
  t42 = in1[3] * in1[5] * in1[6] * t26 * 4.0;
  t43 = in1[4] * in1[5] * in1[6] * t26 * 4.0;
  t46 = in1[5] * t27 + in1[6] * t28;
  t47 = in1[4] * t27 + in1[5] * in1[6] * t25 * -2.0;
  t52 = ((t6 * t25 + t9 * t25) + -(t7 * t25)) + -(t8 * t25);
  memset(&DFcl[0], 0, 55U * sizeof(double));
  DFcl[55] = t15;
  DFcl[56] = t16;
  DFcl[57] = t17;
  t25 = in1[5] * t6 * t26;
  DFcl[58] = -t53 * ((-t29 + t41) + t25 * 4.0);
  DFcl_tmp = in1[4] * t6 * t26;
  DFcl[59] = -t53 * ((t28 + t42) - DFcl_tmp * 4.0);
  b_DFcl_tmp = in1[3] * t7 * t26;
  c_DFcl_tmp = in1[3] * t8 * t26;
  DFcl[60] = t53 * ((((t27 - rt_powd_snf(in1[3], 3.0) * t26 * 2.0) + b_DFcl_tmp *
                      2.0) + c_DFcl_tmp * 2.0) - in1[3] * t9 * t26 * 2.0);
  memset(&DFcl[61], 0, 10U * sizeof(double));
  DFcl[71] = -t15;
  DFcl[72] = 0.0;
  DFcl[73] = -t17;
  DFcl[74] = t16;
  d_DFcl_tmp = in1[6] * t7 * t26;
  DFcl[75] = -t53 * ((-t30 + t40) + d_DFcl_tmp * 4.0);
  DFcl[76] = -t53 * ((t27 + t43) - b_DFcl_tmp * 4.0);
  b_DFcl_tmp = in1[4] * t9 * t26;
  DFcl[77] = -t53 * ((((t28 - rt_powd_snf(in1[4], 3.0) * t26 * 2.0) + DFcl_tmp *
                       2.0) - in1[4] * t8 * t26 * 2.0) + b_DFcl_tmp * 2.0);
  memset(&DFcl[78], 0, 10U * sizeof(double));
  DFcl[88] = -t16;
  DFcl[89] = t17;
  DFcl[90] = 0.0;
  DFcl[91] = -t15;
  DFcl[92] = -t53 * ((-t27 + t43) + c_DFcl_tmp * 4.0);
  DFcl_tmp = in1[6] * t8 * t26;
  DFcl[93] = t53 * ((t30 + t40) - DFcl_tmp * 4.0);
  c_DFcl_tmp = in1[5] * t9 * t26;
  DFcl[94] = -t53 * ((((t29 - rt_powd_snf(in1[5], 3.0) * t26 * 2.0) + t25 * 2.0)
                      - in1[5] * t7 * t26 * 2.0) + c_DFcl_tmp * 2.0);
  memset(&DFcl[95], 0, 10U * sizeof(double));
  DFcl[105] = -t17;
  DFcl[106] = -t16;
  DFcl[107] = t15;
  DFcl[108] = 0.0;
  DFcl[109] = -t53 * ((-t28 + t42) + b_DFcl_tmp * 4.0);
  DFcl[110] = t53 * ((t29 + t41) - c_DFcl_tmp * 4.0);
  DFcl[111] = t53 * ((((t30 - rt_powd_snf(in1[6], 3.0) * t26 * 2.0) - in1[6] *
                       t6 * t26 * 2.0) + d_DFcl_tmp * 2.0) + DFcl_tmp * 2.0);
  DFcl[112] = 0.0;
  DFcl[113] = 0.0;
  DFcl[114] = 0.0;
  DFcl[115] = 0.0;
  DFcl[116] = 0.0;
  DFcl[117] = 0.0;
  DFcl[118] = 0.0;
  DFcl[119] = 1.0;
  memset(&DFcl[120], 0, 17U * sizeof(double));
  DFcl[137] = 1.0;
  memset(&DFcl[138], 0, 17U * sizeof(double));
  DFcl[155] = 1.0;
  memset(&DFcl[156], 0, 17U * sizeof(double));
  DFcl[173] = -t12;
  DFcl[174] = t11;
  DFcl[175] = t14;
  DFcl[176] = -t13;
  DFcl[177] = 0.0;
  DFcl[178] = 0.0;
  DFcl[179] = 0.0;
  DFcl[180] = 0.0;
  DFcl[181] = in1[12] * 0.67984946972288751;
  DFcl[182] = in1[11] * -0.055593774185226569;
  DFcl[183] = 0.0;
  DFcl[184] = 0.0;
  DFcl[185] = 0.0;
  DFcl[186] = 0.0;
  DFcl[187] = 0.0;
  DFcl[188] = 0.0;
  DFcl[189] = 0.0;
  DFcl[190] = -t13;
  DFcl[191] = -t14;
  DFcl[192] = t11;
  DFcl[193] = t12;
  DFcl[194] = 0.0;
  DFcl[195] = 0.0;
  DFcl[196] = 0.0;
  DFcl[197] = in1[12] * -0.64877645999099243;
  DFcl[198] = 0.0;
  DFcl[199] = in1[10] * -0.055593774185226569;
  DFcl[200] = 0.0;
  DFcl[201] = 0.0;
  DFcl[202] = 0.0;
  DFcl[203] = 0.0;
  DFcl[204] = 0.0;
  DFcl[205] = 0.0;
  DFcl[206] = 0.0;
  DFcl[207] = -t14;
  DFcl[208] = t13;
  DFcl[209] = -t12;
  DFcl[210] = t11;
  DFcl[211] = 0.0;
  DFcl[212] = 0.0;
  DFcl[213] = 0.0;
  DFcl[214] = in1[11] * -0.64877645999099243;
  DFcl[215] = in1[10] * 0.67984946972288751;
  memset(&DFcl[216], 0, 12U * sizeof(double));
  DFcl[228] = in1[13] * t46 * 1.98019801980198E-5;
  DFcl[229] = in1[13] * t47 * -1.98019801980198E-5;
  DFcl[230] = in1[13] * t52 * 1.98019801980198E-5;
  DFcl[231] = in1[13] * 1.4142135623730951 * -0.00027022969524095479;
  DFcl[232] = in1[13] * 1.4142135623730951 * -0.00024632227163872729;
  DFcl[233] = in1[13] * -1.9348181270960531E-5;
  DFcl[234] = in1[13] * -0.01285714285714286 - 26.42285714285714;
  memset(&DFcl[235], 0, 10U * sizeof(double));
  DFcl[245] = in1[14] * t46 * 1.98019801980198E-5;
  DFcl[246] = in1[14] * t47 * -1.98019801980198E-5;
  DFcl[247] = in1[14] * t52 * 1.98019801980198E-5;
  DFcl[248] = in1[14] * 1.4142135623730951 * -0.00027022969524095479;
  DFcl[249] = in1[14] * 1.4142135623730951 * 0.00024632227163872729;
  DFcl[250] = in1[14] * 1.9348181270960531E-5;
  DFcl[251] = 0.0;
  DFcl[252] = in1[14] * -0.01285714285714286 - 26.42285714285714;
  memset(&DFcl[253], 0, 9U * sizeof(double));
  DFcl[262] = in1[15] * t46 * 1.98019801980198E-5;
  DFcl[263] = in1[15] * t47 * -1.98019801980198E-5;
  DFcl[264] = in1[15] * t52 * 1.98019801980198E-5;
  DFcl[265] = in1[15] * 1.4142135623730951 * 0.00027022969524095479;
  DFcl[266] = in1[15] * 1.4142135623730951 * 0.00024632227163872729;
  DFcl[267] = in1[15] * -1.9348181270960531E-5;
  DFcl[268] = 0.0;
  DFcl[269] = 0.0;
  DFcl[270] = in1[15] * -0.01285714285714286 - 26.42285714285714;
  memset(&DFcl[271], 0, sizeof(double) << 3);
  DFcl[279] = in1[16] * t46 * 1.98019801980198E-5;
  DFcl[280] = in1[16] * t47 * -1.98019801980198E-5;
  DFcl[281] = in1[16] * t52 * 1.98019801980198E-5;
  DFcl[282] = in1[16] * 1.4142135623730951 * 0.00027022969524095479;
  DFcl[283] = in1[16] * 1.4142135623730951 * -0.00024632227163872729;
  DFcl[284] = in1[16] * 1.9348181270960531E-5;
  DFcl[285] = 0.0;
  DFcl[286] = 0.0;
  DFcl[287] = 0.0;
  DFcl[288] = in1[16] * -0.01285714285714286 - 26.42285714285714;
}

//
// File trailer for matDFcl.cpp
//
// [EOF]
//
