//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: UAVDynamicsGradient.cpp
//
// MATLAB Coder version            : 4.2
// C/C++ source code generated on  : 27-Feb-2020 15:18:20
//

// Include Files
#include <cmath>
#include <math.h>
#include "rt_nonfinite.h"
#include <string.h>
#include "UAVDynamicsGradient.h"

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions

//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_powd_snf(double u0, double u1)
{
  double y;
  double d0;
  double d1;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d0 = std::abs(u0);
    d1 = std::abs(u1);
    if (rtIsInf(u1)) {
      if (d0 == 1.0) {
        y = 1.0;
      } else if (d0 > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

//
// Arguments    : const double X[17]
//                double DF[289]
//                double DG[1156]
// Return Type  : void
//
void UAVDynamicsGradient(const double X[17], double DF[289], double DG[1156])
{
  double t6;
  double t7;
  double t8;
  double t9;
  double t11;
  double t12;
  double t13;
  double t14;
  double t15;
  double t16;
  double t17;
  double t25;
  double t53;
  double t26;
  double t27;
  double t28;
  double t29;
  double t30;
  double t52;
  double t40;
  double t41;
  double t42;
  double t43;
  double t46;
  double t47;
  double DF_tmp;
  double b_DF_tmp;
  double c_DF_tmp;
  double d_DF_tmp;

  // MATDF
  //     DF = MATDF(IN1)
  //     This function was generated by the Symbolic Math Toolbox version 8.3.
  //     27-Feb-2020 15:18:11
  t6 = X[3] * X[3];
  t7 = X[4] * X[4];
  t8 = X[5] * X[5];
  t9 = X[6] * X[6];
  t11 = X[3] / 2.0;
  t12 = X[4] / 2.0;
  t13 = X[5] / 2.0;
  t14 = X[6] / 2.0;
  t15 = X[10] / 2.0;
  t16 = X[11] / 2.0;
  t17 = X[12] / 2.0;
  t25 = 1.0 / (((t6 + t7) + t8) + t9);
  t53 = ((X[13] * X[13] * 9.9009900990099013E-6 + X[14] * X[14] *
          9.9009900990099013E-6) + X[15] * X[15] * 9.9009900990099013E-6) + X[16]
    * X[16] * 9.9009900990099013E-6;
  t26 = t25 * t25;
  t27 = X[3] * t25 * 2.0;
  t28 = X[4] * t25 * 2.0;
  t29 = X[5] * t25 * 2.0;
  t30 = X[6] * t25 * 2.0;
  t52 = X[3] * X[4];
  t40 = t52 * X[5] * t26 * 4.0;
  t41 = t52 * X[6] * t26 * 4.0;
  t42 = X[3] * X[5] * X[6] * t26 * 4.0;
  t43 = X[4] * X[5] * X[6] * t26 * 4.0;
  t46 = X[5] * t27 + X[6] * t28;
  t47 = X[4] * t27 + X[5] * X[6] * t25 * -2.0;
  t52 = ((t6 * t25 + t9 * t25) + -(t7 * t25)) + -(t8 * t25);
  memset(&DF[0], 0, 55U * sizeof(double));
  DF[55] = t15;
  DF[56] = t16;
  DF[57] = t17;
  t25 = X[5] * t6 * t26;
  DF[58] = -t53 * ((-t29 + t41) + t25 * 4.0);
  DF_tmp = X[4] * t6 * t26;
  DF[59] = -t53 * ((t28 + t42) - DF_tmp * 4.0);
  b_DF_tmp = X[3] * t7 * t26;
  c_DF_tmp = X[3] * t8 * t26;
  DF[60] = t53 * ((((t27 - rt_powd_snf(X[3], 3.0) * t26 * 2.0) + b_DF_tmp * 2.0)
                   + c_DF_tmp * 2.0) - X[3] * t9 * t26 * 2.0);
  memset(&DF[61], 0, 10U * sizeof(double));
  DF[71] = -t15;
  DF[72] = 0.0;
  DF[73] = -t17;
  DF[74] = t16;
  d_DF_tmp = X[6] * t7 * t26;
  DF[75] = -t53 * ((-t30 + t40) + d_DF_tmp * 4.0);
  DF[76] = -t53 * ((t27 + t43) - b_DF_tmp * 4.0);
  b_DF_tmp = X[4] * t9 * t26;
  DF[77] = -t53 * ((((t28 - rt_powd_snf(X[4], 3.0) * t26 * 2.0) + DF_tmp * 2.0)
                    - X[4] * t8 * t26 * 2.0) + b_DF_tmp * 2.0);
  memset(&DF[78], 0, 10U * sizeof(double));
  DF[88] = -t16;
  DF[89] = t17;
  DF[90] = 0.0;
  DF[91] = -t15;
  DF[92] = -t53 * ((-t27 + t43) + c_DF_tmp * 4.0);
  DF_tmp = X[6] * t8 * t26;
  DF[93] = t53 * ((t30 + t40) - DF_tmp * 4.0);
  c_DF_tmp = X[5] * t9 * t26;
  DF[94] = -t53 * ((((t29 - rt_powd_snf(X[5], 3.0) * t26 * 2.0) + t25 * 2.0) -
                    X[5] * t7 * t26 * 2.0) + c_DF_tmp * 2.0);
  memset(&DF[95], 0, 10U * sizeof(double));
  DF[105] = -t17;
  DF[106] = -t16;
  DF[107] = t15;
  DF[108] = 0.0;
  DF[109] = -t53 * ((-t28 + t42) + b_DF_tmp * 4.0);
  DF[110] = t53 * ((t29 + t41) - c_DF_tmp * 4.0);
  DF[111] = t53 * ((((t30 - rt_powd_snf(X[6], 3.0) * t26 * 2.0) - X[6] * t6 *
                     t26 * 2.0) + d_DF_tmp * 2.0) + DF_tmp * 2.0);
  DF[112] = 0.0;
  DF[113] = 0.0;
  DF[114] = 0.0;
  DF[115] = 0.0;
  DF[116] = 0.0;
  DF[117] = 0.0;
  DF[118] = 0.0;
  DF[119] = 1.0;
  memset(&DF[120], 0, 17U * sizeof(double));
  DF[137] = 1.0;
  memset(&DF[138], 0, 17U * sizeof(double));
  DF[155] = 1.0;
  memset(&DF[156], 0, 17U * sizeof(double));
  DF[173] = -t12;
  DF[174] = t11;
  DF[175] = t14;
  DF[176] = -t13;
  DF[177] = 0.0;
  DF[178] = 0.0;
  DF[179] = 0.0;
  DF[180] = 0.0;
  DF[181] = X[12] * 0.67984946972288751;
  DF[182] = X[11] * -0.055593774185226569;
  DF[183] = 0.0;
  DF[184] = 0.0;
  DF[185] = 0.0;
  DF[186] = 0.0;
  DF[187] = 0.0;
  DF[188] = 0.0;
  DF[189] = 0.0;
  DF[190] = -t13;
  DF[191] = -t14;
  DF[192] = t11;
  DF[193] = t12;
  DF[194] = 0.0;
  DF[195] = 0.0;
  DF[196] = 0.0;
  DF[197] = X[12] * -0.64877645999099243;
  DF[198] = 0.0;
  DF[199] = X[10] * -0.055593774185226569;
  DF[200] = 0.0;
  DF[201] = 0.0;
  DF[202] = 0.0;
  DF[203] = 0.0;
  DF[204] = 0.0;
  DF[205] = 0.0;
  DF[206] = 0.0;
  DF[207] = -t14;
  DF[208] = t13;
  DF[209] = -t12;
  DF[210] = t11;
  DF[211] = 0.0;
  DF[212] = 0.0;
  DF[213] = 0.0;
  DF[214] = X[11] * -0.64877645999099243;
  DF[215] = X[10] * 0.67984946972288751;
  memset(&DF[216], 0, 12U * sizeof(double));
  DF[228] = X[13] * t46 * 1.98019801980198E-5;
  DF[229] = X[13] * t47 * -1.98019801980198E-5;
  DF[230] = X[13] * t52 * 1.98019801980198E-5;
  DF[231] = X[13] * 1.4142135623730951 * -0.00027022969524095479;
  DF[232] = X[13] * 1.4142135623730951 * -0.00024632227163872729;
  DF[233] = X[13] * -1.9348181270960531E-5;
  DF[234] = X[13] * -0.01285714285714286 - 26.42285714285714;
  memset(&DF[235], 0, 10U * sizeof(double));
  DF[245] = X[14] * t46 * 1.98019801980198E-5;
  DF[246] = X[14] * t47 * -1.98019801980198E-5;
  DF[247] = X[14] * t52 * 1.98019801980198E-5;
  DF[248] = X[14] * 1.4142135623730951 * -0.00027022969524095479;
  DF[249] = X[14] * 1.4142135623730951 * 0.00024632227163872729;
  DF[250] = X[14] * 1.9348181270960531E-5;
  DF[251] = 0.0;
  DF[252] = X[14] * -0.01285714285714286 - 26.42285714285714;
  memset(&DF[253], 0, 9U * sizeof(double));
  DF[262] = X[15] * t46 * 1.98019801980198E-5;
  DF[263] = X[15] * t47 * -1.98019801980198E-5;
  DF[264] = X[15] * t52 * 1.98019801980198E-5;
  DF[265] = X[15] * 1.4142135623730951 * 0.00027022969524095479;
  DF[266] = X[15] * 1.4142135623730951 * 0.00024632227163872729;
  DF[267] = X[15] * -1.9348181270960531E-5;
  DF[268] = 0.0;
  DF[269] = 0.0;
  DF[270] = X[15] * -0.01285714285714286 - 26.42285714285714;
  memset(&DF[271], 0, sizeof(double) << 3);
  DF[279] = X[16] * t46 * 1.98019801980198E-5;
  DF[280] = X[16] * t47 * -1.98019801980198E-5;
  DF[281] = X[16] * t52 * 1.98019801980198E-5;
  DF[282] = X[16] * 1.4142135623730951 * 0.00027022969524095479;
  DF[283] = X[16] * 1.4142135623730951 * -0.00024632227163872729;
  DF[284] = X[16] * 1.9348181270960531E-5;
  DF[285] = 0.0;
  DF[286] = 0.0;
  DF[287] = 0.0;
  DF[288] = X[16] * -0.01285714285714286 - 26.42285714285714;
  memset(&DG[0], 0, 1156U * sizeof(double));
}

//
// File trailer for UAVDynamicsGradient.cpp
//
// [EOF]
//
